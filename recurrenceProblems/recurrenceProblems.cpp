你需要在不超过O(n)的复杂度下，计算出下列问题中的f(n)，答案对10^9 + 7取模。
1. n条直线把平面划分成最多f(n)个区域。
   f(0) = 1, f(n) = f(n - 1) + n 
   f(n) = 1 + n * (n + 1) / 2
   
   mod = 1e9 + 7, 除以2可以写成乘以5e8 + 4 

2. n*n的棋盘上放n个棋子，任意两个棋子不能在同一行或同一列，
   并且主对角线上不可以放棋子，共有f(n)种方案。
   
   f(n) = (n - 1) * (f(n - 1) + f(n - 2))
   转化为：a[1...n]的排列，任意的a[i] != i 
   
   举例：n = 6 
   _ _ 6 _ _ 3   (n - 1) * f(n - 2) 
   _ _ 6 _ _ _   (n - 1) * f(n - 1)
   
   
3. 使用1*1和2*2的瓷砖铺满3*n的地板，共有f(n)种方案。
   f(1) = 1, f(2) = 3, f(3) = 5, f(4) = 11
   f(n) = f(n - 1) + 2 * f(n - 2)


4. 从原点出发，每次向左，向上或向右走一个单位的距离，
   并且不能经过重复的点，总共走n步，共有f(n)种不同的路径。
   
   g(n) : 接下来的一步仍然可以走三个方向，已经走了n步的路径数
   h(n) : 接下来的一步只能走两个方向，已经走了n步的路径数
   g(0) = 1, h(0) = 0 
   
   g(n) = g(n - 1) + h(n - 1) //向上 
   h(n) = 2 * g(n - 1) + h(n - 1) //向左/向右
   
   f(n) = g(n) + h(n) 
   f(n) = 2 * f(n - 1) + f(n - 2)
   
5. n个格子排成一排，每个格子需要涂成RGB三种颜色之一，
   其中R颜色的格子有偶数个的情况共有f(n)种。
   
   g(n) : R颜色的格子有奇数个，共有n个格子的方案数
   
   f(n) = g(n - 1) + 2 * f(n - 1)
   g(n) = f(n - 1) + 2 * g(n - 1) 
    
   
6. 对自然数x做如下操作：如果x是奇数，那么把它加上1；如果x是偶数，那么把它除以2。
   定义g(x)的含义为：自然数x经过最少g(x)次上述操作才会变成1。满足g(x)=n的自然数x共有f(n)个。
   
   倒推发现是fibnacci变形。f(n) = f(n - 1) + f(n - 2)
   
7. 长度为n的01字符串，其中含有子串11，共有f(n)种方案。
	dp[i][j][k] : 字符串的长度为i，最后一位是j，k代表是否已经出现过11，有亿点麻烦 
	
	正难则反，g(n) : 长度为n的01字符串，其中不含子串11，共有g(n)种方案
	g(n) = g(n - 1) + g(n - 2)
	f(n) = Pow(2, n) - g(n) 

8. n*n的正方形网格，其中共有f(n)个正方形。
	f(n) = 1*1 + 2*2 + ... + n*n
	     = f(n - 1) + n*n
	     = n * (n + 1) * (2*n + 1) / 6

9. n个折线(折线可以看成两个起点相同的射线)最多把平面划分成f(n)个区域。
    f(1) = 2, f(2) = 7, f(n) = f(n - 1) + 4*n - 3
    f(n) = 2*n*n - n + 1

10. 某种二叉树满足：如果某个非叶结点是父节点的左儿子，那么这个结点仅有右儿子。
    如果某个非叶结点是根结点或者是父结点的右儿子，那么这个结点既有左儿子又有右儿子。
    深度为n的满足以上性质的二叉树最多有f(n)个叶子结点。
    Fibnacci数列变形。f(n) = f(n - 1) + f(n - 2) 
    
11. 长度为n的由0，1，2组成的数列，所有数的总和是3的倍数。这样的数列共有f(n)种。
	dp[i][j] : 前i个数，总和%3=j，有多少种方案
	
	dp[i][0] = dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2] 
	dp[i][1] = dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2] 
	dp[i][2] = dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2] 
	
	f(n) = pow(3, n - 1)

12. 长度为n的由0，1，2，3组成的数列，所有数的总和是3的倍数。这样的数列共有f(n)种。
    dp[i][j] : 前i个数，总和%3=j，有多少种方案
	
	dp[i][0] = dp[i - 1][0] * 2 + dp[i - 1][1] + dp[i - 1][2] 
	dp[i][1] = dp[i - 1][0] + dp[i - 1][1] * 2 + dp[i - 1][2] 
	dp[i][2] = dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2] * 2
	
	f(n) = dp[n][0] + dp[n][1] + dp[n][2]
    

13. 登上n级台阶，每次可以向上攀登1，2或3级台阶，或后退1级台阶。
	但是每次后退1级台阶的下一步必须向上攀登2或3级台阶。
	位于起点时不能后退。共有f(n)种不同的方案。
	
	f(n) = f(n - 1) * 2 + f(n - 2) * 2 + f(n - 3)  注意边界 
	
	
14. 登上n级台阶，每次可以向上攀登任意奇数级台阶。共有f(n)种不同的方案。
	g(n) = f(1) + f(3) + ... + f(n) //或f(n-1)
	h(n) = f(0) + f(2) + ... + f(n) //或f(n-1)
	
	f(n) = (n % 2 == 1 ? h(n - 1) : g(n - 1));
	g(n) = (n % 2 == 1 ? f(n) : 0) + g(n - 1);
	h(n) = (n % 2 == 0 ? f(n) : 0) + h(n - 1);
	 

你需要在不超过O(n^2)的复杂度下，计算出下列问题中的f(n)，答案对10^9 + 7取模。
1. 长度为2*n的只包含'('，')'的字符串，并且该字符串的所有括号都能合法匹配。
   这样的字符串共有f(n)种。
   
   卡特兰Catalan数 
   (...2*k...)...2(n-k-1)...
   f(n) = f(0) * f(n - 1) + f(1) * f(n - 2) + ... + f(n - 1) * f(0)
   
2. 在平面直角坐标系中，从原点(0,0)出发，每次可以向右或者向上走一个单位的距离，
   最终走到坐标(n,n)。但是任何时候纵坐标都不能大于横坐标。共有f(n)种走法。
   
   向右走=左括号，向上走=右括号，纵坐标不能大于横坐标=对于任何前缀，右括号<=左括号 
   
3. 中序遍历为1，2，...，n的二叉树共有f(n)种。 
	假设根节点是k，那么它的左子树结点有k-1个，右子树结点有n-k个，
	所以直接得到f(n) = sum{f(k - 1) * f(n - k)}, 1 <= k <= n 

4. 入栈序列为1，2，...，n，出栈序列共有f(n)种可能。栈的起始状态和最终状态都是空栈。
    入栈=左括号，出栈=右括号 

你需要在不超过O(max(n,m))的复杂度下，计算出下列问题中的f(n,m)，答案对10^9 + 7取模。
1. n*m的长方形网格，其中共有f(n,m)个长方形。
	长有n * (n + 1) / 2, 宽有m * (m + 1) / 2
	f(n) = n * (n + 1) / 2 * m * (m + 1) / 2;

2. n*m的长方形网格，每个小格子都是正方形。其中共有f(n,m)个正方形。
	f(n, m) = n*m + (n - 1)*(m - 1) + ... 

3. 登上n级台阶，每次可以向上攀登不超过m级台阶，但每次至少攀登1级。共有f(n,m)种不同的方案。
    dp[n] = dp[n - m] + dp[n - m + 1] + ... + dp[n - 1];
    维护dp的前缀和计算即可，注意减法取模 

你需要在不超过O(nm)的复杂度下，计算出下列问题中的f(n,m)，答案对10^9 + 7取模。
1. 在平面直角坐标系中，从原点(0,0)出发，每次可以向右或者向上走一个单位的距离，
   最终走到坐标(n,m)。共有f(n,m)种走法。
    f(n,m) = C(n+m, n)
	f(n,m) = f(n-1,m) + f(n,m-1)
   
2. 长度为n的正整数数组a[1...n]，数组的总和为m。这样的数组共有f(n,m)种可能。
	f(n,m) = f(n-1, m-1) + f(n-1, m-2) + ... + f(n-1, n-1)
	
	数组的总和为m，看成m个小球排成一排
	n个正整数，看成n-1个隔板
	ooo|oo|oooo 
	f(n,m) = C(n - 1, m - 1); 

3. 在数轴上从原点出发，每次可以向左或者向右走一个单位的距离，共走n步，最终走到m。
   共有f(n,m)种走法。
    f(n,m) = f(n-1, m-1) + f(n-1, m+1) 第二维可以为负，所以+n
	或者使用组合数 
    
   
4. 把n个不同的小球放进m个相同的盒子中，并且所有的盒子都不能为空。共有f(n,m)种放法。
    考虑第n个小球放在哪里。
	如果第n个小球所在的盒子只有它自己，f(n-1, m-1)
	否则，第n个小球所在的盒子还有其他小球，m * f(n-1, m) 
	
	f(n,m) = f(n-1, m-1) + m * f(n-1, m)
	第二类斯特林数/斯特林子集数
